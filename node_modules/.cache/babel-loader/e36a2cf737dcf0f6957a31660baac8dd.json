{"ast":null,"code":"'use strict';\n\nvar hasOwn = require('hasown');\nvar VALIDATE = require('./validate');\nmodule.exports = function (REGION) {\n  var MAX = Math.max;\n  var MIN = Math.min;\n  var statics = {\n    init: function () {\n      var exportAsNonStatic = {\n        getIntersection: true,\n        getIntersectionArea: true,\n        getIntersectionHeight: true,\n        getIntersectionWidth: true,\n        getUnion: true\n      };\n      var thisProto = REGION.prototype;\n      var newName;\n      var exportHasOwn = hasOwn(exportAsNonStatic);\n      var methodName;\n      for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n        newName = exportAsNonStatic[methodName];\n        if (typeof newName != 'string') {\n          newName = methodName;\n        }\n        ;\n        (function (proto, methodName, protoMethodName) {\n          proto[methodName] = function (region) {\n            //<debug>\n            if (!REGION[protoMethodName]) {\n              console.warn('cannot find method ', protoMethodName, ' on ', REGION);\n            }\n            //</debug>\n            return REGION[protoMethodName](this, region);\n          };\n        })(thisProto, newName, methodName);\n      }\n    },\n    validate: VALIDATE,\n    /**\n     * Returns the region corresponding to the documentElement\n     * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n     */\n    getDocRegion: function () {\n      return REGION.fromDOM(document.documentElement);\n    },\n    from: function (reg) {\n      if (reg.__IS_REGION) {\n        return reg;\n      }\n      if (typeof document != 'undefined') {\n        if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement) {\n          return REGION.fromDOM(reg);\n        }\n        if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined') {\n          return REGION.fromEvent(reg);\n        }\n      }\n      return REGION(reg);\n    },\n    fromEvent: function (event) {\n      return REGION.fromPoint({\n        x: event.pageX,\n        y: event.pageY\n      });\n    },\n    fromDOM: function (dom) {\n      var rect = dom.getBoundingClientRect();\n      // var docElem = document.documentElement\n      // var win     = window\n\n      // var top  = rect.top + win.pageYOffset - docElem.clientTop\n      // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n      return new REGION({\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.bottom,\n        right: rect.right\n      });\n    },\n    /**\n     * @static\n     * Returns a region that is the intersection of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region/Boolean}        The intersection region or false if no intersection found\n     */\n    getIntersection: function (first, second) {\n      var area = this.getIntersectionArea(first, second);\n      if (area) {\n        return new REGION(area);\n      }\n      return false;\n    },\n    getIntersectionWidth: function (first, second) {\n      var minRight = MIN(first.right, second.right);\n      var maxLeft = MAX(first.left, second.left);\n      if (maxLeft < minRight) {\n        return minRight - maxLeft;\n      }\n      return 0;\n    },\n    getIntersectionHeight: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minBottom = MIN(first.bottom, second.bottom);\n      if (maxTop < minBottom) {\n        return minBottom - maxTop;\n      }\n      return 0;\n    },\n    getIntersectionArea: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minRight = MIN(first.right, second.right);\n      var minBottom = MIN(first.bottom, second.bottom);\n      var maxLeft = MAX(first.left, second.left);\n      if (maxTop < minBottom && maxLeft < minRight) {\n        return {\n          top: maxTop,\n          right: minRight,\n          bottom: minBottom,\n          left: maxLeft,\n          width: minRight - maxLeft,\n          height: minBottom - maxTop\n        };\n      }\n      return false;\n    },\n    /**\n     * @static\n     * Returns a region that is the union of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region}        The union region. The smallest region that contains both given regions.\n     */\n    getUnion: function (first, second) {\n      var top = MIN(first.top, second.top);\n      var right = MAX(first.right, second.right);\n      var bottom = MAX(first.bottom, second.bottom);\n      var left = MIN(first.left, second.left);\n      return new REGION(top, right, bottom, left);\n    },\n    /**\n     * @static\n     * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n     *\n     * @param  {Region} reg A region or an object with either top, left, bottom, right or\n     * with top, left, width, height\n     * @return {Region} A region\n     */\n    getRegion: function (reg) {\n      return REGION.from(reg);\n    },\n    /**\n     * Creates a region that corresponds to a point.\n     *\n     * @param  {Object} xy The point\n     * @param  {Number} xy.x\n     * @param  {Number} xy.y\n     *\n     * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n     */\n    fromPoint: function (xy) {\n      return new REGION({\n        top: xy.y,\n        bottom: xy.y,\n        left: xy.x,\n        right: xy.x\n      });\n    }\n  };\n  Object.keys(statics).forEach(function (key) {\n    REGION[key] = statics[key];\n  });\n  REGION.init();\n};","map":{"version":3,"names":["hasOwn","require","VALIDATE","module","exports","REGION","MAX","Math","max","MIN","min","statics","init","exportAsNonStatic","getIntersection","getIntersectionArea","getIntersectionHeight","getIntersectionWidth","getUnion","thisProto","prototype","newName","exportHasOwn","methodName","proto","protoMethodName","region","console","warn","validate","getDocRegion","fromDOM","document","documentElement","from","reg","__IS_REGION","HTMLElement","type","pageX","pageY","fromEvent","event","fromPoint","x","y","dom","rect","getBoundingClientRect","top","left","bottom","right","first","second","area","minRight","maxLeft","maxTop","minBottom","width","height","getRegion","xy","Object","keys","forEach","key"],"sources":["/home/ocode-2023/Desktop/Dashboard/Admin/node_modules/region/src/statics.js"],"sourcesContent":["'use strict';\n\nvar hasOwn   = require('hasown')\nvar VALIDATE = require('./validate')\n\nmodule.exports = function(REGION){\n\n    var MAX = Math.max\n    var MIN = Math.min\n\n    var statics = {\n        init: function(){\n            var exportAsNonStatic = {\n                getIntersection      : true,\n                getIntersectionArea  : true,\n                getIntersectionHeight: true,\n                getIntersectionWidth : true,\n                getUnion             : true\n            }\n            var thisProto = REGION.prototype\n            var newName\n\n            var exportHasOwn = hasOwn(exportAsNonStatic)\n            var methodName\n\n            for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n                newName = exportAsNonStatic[methodName]\n                if (typeof newName != 'string'){\n                    newName = methodName\n                }\n\n                ;(function(proto, methodName, protoMethodName){\n\n                    proto[methodName] = function(region){\n                        //<debug>\n                        if (!REGION[protoMethodName]){\n                            console.warn('cannot find method ', protoMethodName,' on ', REGION)\n                        }\n                        //</debug>\n                        return REGION[protoMethodName](this, region)\n                    }\n\n                })(thisProto, newName, methodName);\n            }\n        },\n\n        validate: VALIDATE,\n\n        /**\n         * Returns the region corresponding to the documentElement\n         * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n         */\n        getDocRegion: function(){\n            return REGION.fromDOM(document.documentElement)\n        },\n\n        from: function(reg){\n            if (reg.__IS_REGION){\n                return reg\n            }\n\n            if (typeof document != 'undefined'){\n                if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement){\n                    return REGION.fromDOM(reg)\n                }\n\n                if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined'){\n                    return REGION.fromEvent(reg)\n                }\n            }\n\n            return REGION(reg)\n        },\n\n        fromEvent: function(event){\n            return REGION.fromPoint({\n                x: event.pageX,\n                y: event.pageY\n            })\n        },\n\n        fromDOM: function(dom){\n            var rect = dom.getBoundingClientRect()\n            // var docElem = document.documentElement\n            // var win     = window\n\n            // var top  = rect.top + win.pageYOffset - docElem.clientTop\n            // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n            return new REGION({\n                top   : rect.top,\n                left  : rect.left,\n                bottom: rect.bottom,\n                right : rect.right\n            })\n        },\n\n        /**\n         * @static\n         * Returns a region that is the intersection of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region/Boolean}        The intersection region or false if no intersection found\n         */\n        getIntersection: function(first, second){\n\n            var area = this.getIntersectionArea(first, second)\n\n            if (area){\n                return new REGION(area)\n            }\n\n            return false\n        },\n\n        getIntersectionWidth: function(first, second){\n            var minRight  = MIN(first.right, second.right)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (maxLeft < minRight){\n                return minRight  - maxLeft\n            }\n\n            return 0\n        },\n\n        getIntersectionHeight: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minBottom = MIN(first.bottom,second.bottom)\n\n            if (maxTop  < minBottom){\n                return minBottom - maxTop\n            }\n\n            return 0\n        },\n\n        getIntersectionArea: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minRight  = MIN(first.right, second.right)\n            var minBottom = MIN(first.bottom,second.bottom)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (\n                    maxTop  < minBottom &&\n                    maxLeft < minRight\n                ){\n                return {\n                    top    : maxTop,\n                    right  : minRight,\n                    bottom : minBottom,\n                    left   : maxLeft,\n\n                    width  : minRight  - maxLeft,\n                    height : minBottom - maxTop\n                }\n            }\n\n            return false\n        },\n\n        /**\n         * @static\n         * Returns a region that is the union of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region}        The union region. The smallest region that contains both given regions.\n         */\n        getUnion: function(first, second){\n            var top    = MIN(first.top,   second.top)\n            var right  = MAX(first.right, second.right)\n            var bottom = MAX(first.bottom,second.bottom)\n            var left   = MIN(first.left,  second.left)\n\n            return new REGION(top, right, bottom, left)\n        },\n\n        /**\n         * @static\n         * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n         *\n         * @param  {Region} reg A region or an object with either top, left, bottom, right or\n         * with top, left, width, height\n         * @return {Region} A region\n         */\n        getRegion: function(reg){\n            return REGION.from(reg)\n        },\n\n        /**\n         * Creates a region that corresponds to a point.\n         *\n         * @param  {Object} xy The point\n         * @param  {Number} xy.x\n         * @param  {Number} xy.y\n         *\n         * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n         */\n        fromPoint: function(xy){\n            return new REGION({\n                        top    : xy.y,\n                        bottom : xy.y,\n                        left   : xy.x,\n                        right  : xy.x\n                    })\n        }\n    }\n\n    Object.keys(statics).forEach(function(key){\n        REGION[key] = statics[key]\n    })\n\n    REGION.init()\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}