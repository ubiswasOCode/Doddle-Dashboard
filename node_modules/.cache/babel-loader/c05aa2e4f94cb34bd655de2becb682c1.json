{"ast":null,"code":"'use strict';\n\nvar Region = require('region');\n/**\n *\n * This method is trying to align the sourceRegion to the targetRegion, given the alignment positions\n * and the offsets. It only modifies the sourceRegion\n *\n * This is all well and easy, but if there is a constrainTo region, the algorithm has to take it into account.\n * In this case, it works as follows.\n *\n *  * start with the first alignment position. Aligns the region, adds the offset and then check for the constraint.\n *  * if the constraint condition is ok, return the position.\n *  * otherwise, remember the intersection area, if the regions are intersecting.\n *  * then go to the next specified align position, and so on, computing the maximum intersection area.\n *\n * If no alignment fits the constrainRegion, the sourceRegion will be resized to match it,\n * using the position with the maximum intersection area.\n *\n * Since we have computed the index of the position with the max intersection area, take that position,\n * and align the sourceRegion accordingly. Then resize the sourceRegion to the intersection, and reposition\n * it again, since resizing it might have destroyed the alignment.\n *\n * Return the position.\n *\n * @param {Region} sourceRegion\n * @param {Region} targetRegion\n * @param {String[]} positions\n * @param {Object} config\n * @param {Array} config.offset\n * @param {Region} config.constrain\n * @param {Boolean/Object} config.sync\n *\n * @return {String/Undefined} the chosen position for the alignment, or undefined if no position found\n */\n\n\nfunction ALIGN_TO_NORMALIZED(sourceRegion, targetRegion, positions, config) {\n  targetRegion = Region.from(targetRegion);\n  config = config || {};\n  var constrainTo = config.constrain,\n      syncOption = config.sync,\n      offsets = config.offset || [],\n      syncWidth = false,\n      syncHeight = false,\n      sourceClone = sourceRegion.clone();\n  /*\n   * Prepare the method arguments: positions, offsets, constrain and sync options\n   */\n\n  if (!Array.isArray(positions)) {\n    positions = positions ? [positions] : [];\n  }\n\n  if (!Array.isArray(offsets)) {\n    offsets = offsets ? [offsets] : [];\n  }\n\n  if (constrainTo) {\n    constrainTo = constrainTo === true ? Region.getDocRegion() : constrainTo.getRegion();\n  }\n\n  if (syncOption) {\n    if (syncOption.size) {\n      syncWidth = true;\n      syncHeight = true;\n    } else {\n      syncWidth = syncOption === true ? true : syncOption.width || false;\n      syncHeight = syncOption === true ? true : syncOption.height || false;\n    }\n  }\n\n  if (syncWidth) {\n    sourceClone.setWidth(targetRegion.getWidth());\n  }\n\n  if (syncHeight) {\n    sourceClone.setHeight(targetRegion.getHeight());\n  }\n\n  var offset,\n      i = 0,\n      len = positions.length,\n      pos,\n      intersection,\n      itArea,\n      maxArea = -1,\n      maxAreaIndex = -1;\n\n  for (; i < len; i++) {\n    pos = positions[i];\n    offset = offsets[i];\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      if (!Array.isArray(offset)) {\n        offset = offsets[i] = [offset.x || offset.left, offset.y || offset.top];\n      }\n\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    } //the source region is already aligned in the correct position\n\n\n    if (constrainTo) {\n      //if we have a constrain region, test for the constrain\n      intersection = sourceClone.getIntersection(constrainTo);\n\n      if (intersection && intersection.equals(sourceClone)) {\n        //constrain respected, so return (the aligned position)\n        sourceRegion.set(sourceClone);\n        return pos;\n      } else {\n        //the constrain was not respected, so continue trying\n        if (intersection && (itArea = intersection.getArea()) > maxArea) {\n          maxArea = itArea;\n          maxAreaIndex = i;\n        }\n      }\n    } else {\n      sourceRegion.set(sourceClone);\n      return pos;\n    }\n  } //no alignment respected the constraints\n\n\n  if (~maxAreaIndex) {\n    pos = positions[maxAreaIndex];\n    offset = offsets[maxAreaIndex];\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    } //we are sure an intersection exists, because of the way the maxAreaIndex was computed\n\n\n    intersection = sourceClone.getIntersection(constrainTo);\n    sourceClone.setRegion(intersection);\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    }\n\n    sourceRegion.set(sourceClone);\n    return pos;\n  }\n}\n\nmodule.exports = ALIGN_TO_NORMALIZED;","map":{"version":3,"sources":["/home/ocode/Downloads/Admin/node_modules/region-align/alignToNormalized.js"],"names":["Region","require","ALIGN_TO_NORMALIZED","sourceRegion","targetRegion","positions","config","from","constrainTo","constrain","syncOption","sync","offsets","offset","syncWidth","syncHeight","sourceClone","clone","Array","isArray","getDocRegion","getRegion","size","width","height","setWidth","getWidth","setHeight","getHeight","i","len","length","pos","intersection","itArea","maxArea","maxAreaIndex","alignToRegion","x","left","y","top","shift","getIntersection","equals","set","getArea","setRegion","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar Region = require('region')\n\n/**\n *\n * This method is trying to align the sourceRegion to the targetRegion, given the alignment positions\n * and the offsets. It only modifies the sourceRegion\n *\n * This is all well and easy, but if there is a constrainTo region, the algorithm has to take it into account.\n * In this case, it works as follows.\n *\n *  * start with the first alignment position. Aligns the region, adds the offset and then check for the constraint.\n *  * if the constraint condition is ok, return the position.\n *  * otherwise, remember the intersection area, if the regions are intersecting.\n *  * then go to the next specified align position, and so on, computing the maximum intersection area.\n *\n * If no alignment fits the constrainRegion, the sourceRegion will be resized to match it,\n * using the position with the maximum intersection area.\n *\n * Since we have computed the index of the position with the max intersection area, take that position,\n * and align the sourceRegion accordingly. Then resize the sourceRegion to the intersection, and reposition\n * it again, since resizing it might have destroyed the alignment.\n *\n * Return the position.\n *\n * @param {Region} sourceRegion\n * @param {Region} targetRegion\n * @param {String[]} positions\n * @param {Object} config\n * @param {Array} config.offset\n * @param {Region} config.constrain\n * @param {Boolean/Object} config.sync\n *\n * @return {String/Undefined} the chosen position for the alignment, or undefined if no position found\n */\nfunction ALIGN_TO_NORMALIZED(sourceRegion, targetRegion, positions, config){\n\n    targetRegion = Region.from(targetRegion)\n\n    config = config  || {}\n\n    var constrainTo = config.constrain,\n        syncOption  = config.sync,\n        offsets     = config.offset || [],\n        syncWidth   = false,\n        syncHeight  = false,\n        sourceClone = sourceRegion.clone()\n\n    /*\n     * Prepare the method arguments: positions, offsets, constrain and sync options\n     */\n    if (!Array.isArray(positions)){\n        positions = positions? [positions]: []\n    }\n\n    if (!Array.isArray(offsets)){\n        offsets = offsets? [offsets]: []\n    }\n\n    if (constrainTo){\n        constrainTo = constrainTo === true?\n                                Region.getDocRegion():\n                                constrainTo.getRegion()\n    }\n\n    if (syncOption){\n\n        if (syncOption.size){\n            syncWidth  = true\n            syncHeight = true\n        } else {\n            syncWidth  = syncOption === true?\n                            true:\n                            syncOption.width || false\n\n            syncHeight = syncOption === true?\n                            true:\n                            syncOption.height || false\n        }\n    }\n\n    if (syncWidth){\n        sourceClone.setWidth(targetRegion.getWidth())\n    }\n    if (syncHeight){\n        sourceClone.setHeight(targetRegion.getHeight())\n\n    }\n\n    var offset,\n        i = 0,\n        len = positions.length,\n        pos,\n        intersection,\n        itArea,\n        maxArea = -1,\n        maxAreaIndex = -1\n\n    for (; i < len; i++){\n        pos     = positions[i]\n        offset  = offsets[i]\n\n        sourceClone.alignToRegion(targetRegion, pos)\n\n        if (offset){\n            if (!Array.isArray(offset)){\n                offset = offsets[i] = [offset.x || offset.left, offset.y || offset.top]\n            }\n\n            sourceClone.shift({\n                left: offset[0],\n                top : offset[1]\n            })\n        }\n\n        //the source region is already aligned in the correct position\n\n        if (constrainTo){\n            //if we have a constrain region, test for the constrain\n            intersection = sourceClone.getIntersection(constrainTo)\n\n            if ( intersection && intersection.equals(sourceClone) ) {\n                //constrain respected, so return (the aligned position)\n\n                sourceRegion.set(sourceClone)\n                return pos\n            } else {\n\n                //the constrain was not respected, so continue trying\n                if (intersection && ((itArea = intersection.getArea()) > maxArea)){\n                    maxArea      = itArea\n                    maxAreaIndex = i\n                }\n            }\n\n        } else {\n            sourceRegion.set(sourceClone)\n            return pos\n        }\n    }\n\n    //no alignment respected the constraints\n    if (~maxAreaIndex){\n        pos     = positions[maxAreaIndex]\n        offset  = offsets[maxAreaIndex]\n\n        sourceClone.alignToRegion(targetRegion, pos)\n\n        if (offset){\n            sourceClone.shift({\n                left: offset[0],\n                top : offset[1]\n            })\n        }\n\n        //we are sure an intersection exists, because of the way the maxAreaIndex was computed\n        intersection = sourceClone.getIntersection(constrainTo)\n\n        sourceClone.setRegion(intersection)\n        sourceClone.alignToRegion(targetRegion, pos)\n\n        if (offset){\n            sourceClone.shift({\n                left: offset[0],\n                top : offset[1]\n            })\n        }\n\n        sourceRegion.set(sourceClone)\n\n        return pos\n    }\n\n}\n\nmodule.exports = ALIGN_TO_NORMALIZED"]},"metadata":{},"sourceType":"script"}