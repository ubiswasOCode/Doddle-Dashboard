{"ast":null,"code":"'use strict';\n\nvar hasOwn = require('hasown');\n\nvar VALIDATE = require('./validate');\n\nmodule.exports = function (REGION) {\n  var MAX = Math.max;\n  var MIN = Math.min;\n  var statics = {\n    init: function () {\n      var exportAsNonStatic = {\n        getIntersection: true,\n        getIntersectionArea: true,\n        getIntersectionHeight: true,\n        getIntersectionWidth: true,\n        getUnion: true\n      };\n      var thisProto = REGION.prototype;\n      var newName;\n      var exportHasOwn = hasOwn(exportAsNonStatic);\n      var methodName;\n\n      for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n        newName = exportAsNonStatic[methodName];\n\n        if (typeof newName != 'string') {\n          newName = methodName;\n        }\n\n        ;\n\n        (function (proto, methodName, protoMethodName) {\n          proto[methodName] = function (region) {\n            //<debug>\n            if (!REGION[protoMethodName]) {\n              console.warn('cannot find method ', protoMethodName, ' on ', REGION);\n            } //</debug>\n\n\n            return REGION[protoMethodName](this, region);\n          };\n        })(thisProto, newName, methodName);\n      }\n    },\n    validate: VALIDATE,\n\n    /**\n     * Returns the region corresponding to the documentElement\n     * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n     */\n    getDocRegion: function () {\n      return REGION.fromDOM(document.documentElement);\n    },\n    from: function (reg) {\n      if (reg.__IS_REGION) {\n        return reg;\n      }\n\n      if (typeof document != 'undefined') {\n        if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement) {\n          return REGION.fromDOM(reg);\n        }\n\n        if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined') {\n          return REGION.fromEvent(reg);\n        }\n      }\n\n      return REGION(reg);\n    },\n    fromEvent: function (event) {\n      return REGION.fromPoint({\n        x: event.pageX,\n        y: event.pageY\n      });\n    },\n    fromDOM: function (dom) {\n      var rect = dom.getBoundingClientRect(); // var docElem = document.documentElement\n      // var win     = window\n      // var top  = rect.top + win.pageYOffset - docElem.clientTop\n      // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n      return new REGION({\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.bottom,\n        right: rect.right\n      });\n    },\n\n    /**\n     * @static\n     * Returns a region that is the intersection of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region/Boolean}        The intersection region or false if no intersection found\n     */\n    getIntersection: function (first, second) {\n      var area = this.getIntersectionArea(first, second);\n\n      if (area) {\n        return new REGION(area);\n      }\n\n      return false;\n    },\n    getIntersectionWidth: function (first, second) {\n      var minRight = MIN(first.right, second.right);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxLeft < minRight) {\n        return minRight - maxLeft;\n      }\n\n      return 0;\n    },\n    getIntersectionHeight: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minBottom = MIN(first.bottom, second.bottom);\n\n      if (maxTop < minBottom) {\n        return minBottom - maxTop;\n      }\n\n      return 0;\n    },\n    getIntersectionArea: function (first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minRight = MIN(first.right, second.right);\n      var minBottom = MIN(first.bottom, second.bottom);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxTop < minBottom && maxLeft < minRight) {\n        return {\n          top: maxTop,\n          right: minRight,\n          bottom: minBottom,\n          left: maxLeft,\n          width: minRight - maxLeft,\n          height: minBottom - maxTop\n        };\n      }\n\n      return false;\n    },\n\n    /**\n     * @static\n     * Returns a region that is the union of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region}        The union region. The smallest region that contains both given regions.\n     */\n    getUnion: function (first, second) {\n      var top = MIN(first.top, second.top);\n      var right = MAX(first.right, second.right);\n      var bottom = MAX(first.bottom, second.bottom);\n      var left = MIN(first.left, second.left);\n      return new REGION(top, right, bottom, left);\n    },\n\n    /**\n     * @static\n     * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n     *\n     * @param  {Region} reg A region or an object with either top, left, bottom, right or\n     * with top, left, width, height\n     * @return {Region} A region\n     */\n    getRegion: function (reg) {\n      return REGION.from(reg);\n    },\n\n    /**\n     * Creates a region that corresponds to a point.\n     *\n     * @param  {Object} xy The point\n     * @param  {Number} xy.x\n     * @param  {Number} xy.y\n     *\n     * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n     */\n    fromPoint: function (xy) {\n      return new REGION({\n        top: xy.y,\n        bottom: xy.y,\n        left: xy.x,\n        right: xy.x\n      });\n    }\n  };\n  Object.keys(statics).forEach(function (key) {\n    REGION[key] = statics[key];\n  });\n  REGION.init();\n};","map":{"version":3,"sources":["/home/ocode/Downloads/Admin/node_modules/region/src/statics.js"],"names":["hasOwn","require","VALIDATE","module","exports","REGION","MAX","Math","max","MIN","min","statics","init","exportAsNonStatic","getIntersection","getIntersectionArea","getIntersectionHeight","getIntersectionWidth","getUnion","thisProto","prototype","newName","exportHasOwn","methodName","proto","protoMethodName","region","console","warn","validate","getDocRegion","fromDOM","document","documentElement","from","reg","__IS_REGION","HTMLElement","type","pageX","pageY","fromEvent","event","fromPoint","x","y","dom","rect","getBoundingClientRect","top","left","bottom","right","first","second","area","minRight","maxLeft","maxTop","minBottom","width","height","getRegion","xy","Object","keys","forEach","key"],"mappings":"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","sourcesContent":["'use strict';\n\nvar hasOwn   = require('hasown')\nvar VALIDATE = require('./validate')\n\nmodule.exports = function(REGION){\n\n    var MAX = Math.max\n    var MIN = Math.min\n\n    var statics = {\n        init: function(){\n            var exportAsNonStatic = {\n                getIntersection      : true,\n                getIntersectionArea  : true,\n                getIntersectionHeight: true,\n                getIntersectionWidth : true,\n                getUnion             : true\n            }\n            var thisProto = REGION.prototype\n            var newName\n\n            var exportHasOwn = hasOwn(exportAsNonStatic)\n            var methodName\n\n            for (methodName in exportAsNonStatic) if (exportHasOwn(methodName)) {\n                newName = exportAsNonStatic[methodName]\n                if (typeof newName != 'string'){\n                    newName = methodName\n                }\n\n                ;(function(proto, methodName, protoMethodName){\n\n                    proto[methodName] = function(region){\n                        //<debug>\n                        if (!REGION[protoMethodName]){\n                            console.warn('cannot find method ', protoMethodName,' on ', REGION)\n                        }\n                        //</debug>\n                        return REGION[protoMethodName](this, region)\n                    }\n\n                })(thisProto, newName, methodName);\n            }\n        },\n\n        validate: VALIDATE,\n\n        /**\n         * Returns the region corresponding to the documentElement\n         * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n         */\n        getDocRegion: function(){\n            return REGION.fromDOM(document.documentElement)\n        },\n\n        from: function(reg){\n            if (reg.__IS_REGION){\n                return reg\n            }\n\n            if (typeof document != 'undefined'){\n                if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement){\n                    return REGION.fromDOM(reg)\n                }\n\n                if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined'){\n                    return REGION.fromEvent(reg)\n                }\n            }\n\n            return REGION(reg)\n        },\n\n        fromEvent: function(event){\n            return REGION.fromPoint({\n                x: event.pageX,\n                y: event.pageY\n            })\n        },\n\n        fromDOM: function(dom){\n            var rect = dom.getBoundingClientRect()\n            // var docElem = document.documentElement\n            // var win     = window\n\n            // var top  = rect.top + win.pageYOffset - docElem.clientTop\n            // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n            return new REGION({\n                top   : rect.top,\n                left  : rect.left,\n                bottom: rect.bottom,\n                right : rect.right\n            })\n        },\n\n        /**\n         * @static\n         * Returns a region that is the intersection of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region/Boolean}        The intersection region or false if no intersection found\n         */\n        getIntersection: function(first, second){\n\n            var area = this.getIntersectionArea(first, second)\n\n            if (area){\n                return new REGION(area)\n            }\n\n            return false\n        },\n\n        getIntersectionWidth: function(first, second){\n            var minRight  = MIN(first.right, second.right)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (maxLeft < minRight){\n                return minRight  - maxLeft\n            }\n\n            return 0\n        },\n\n        getIntersectionHeight: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minBottom = MIN(first.bottom,second.bottom)\n\n            if (maxTop  < minBottom){\n                return minBottom - maxTop\n            }\n\n            return 0\n        },\n\n        getIntersectionArea: function(first, second){\n            var maxTop    = MAX(first.top,   second.top)\n            var minRight  = MIN(first.right, second.right)\n            var minBottom = MIN(first.bottom,second.bottom)\n            var maxLeft   = MAX(first.left,  second.left)\n\n            if (\n                    maxTop  < minBottom &&\n                    maxLeft < minRight\n                ){\n                return {\n                    top    : maxTop,\n                    right  : minRight,\n                    bottom : minBottom,\n                    left   : maxLeft,\n\n                    width  : minRight  - maxLeft,\n                    height : minBottom - maxTop\n                }\n            }\n\n            return false\n        },\n\n        /**\n         * @static\n         * Returns a region that is the union of the given two regions\n         * @param  {Region} first  The first region\n         * @param  {Region} second The second region\n         * @return {Region}        The union region. The smallest region that contains both given regions.\n         */\n        getUnion: function(first, second){\n            var top    = MIN(first.top,   second.top)\n            var right  = MAX(first.right, second.right)\n            var bottom = MAX(first.bottom,second.bottom)\n            var left   = MIN(first.left,  second.left)\n\n            return new REGION(top, right, bottom, left)\n        },\n\n        /**\n         * @static\n         * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n         *\n         * @param  {Region} reg A region or an object with either top, left, bottom, right or\n         * with top, left, width, height\n         * @return {Region} A region\n         */\n        getRegion: function(reg){\n            return REGION.from(reg)\n        },\n\n        /**\n         * Creates a region that corresponds to a point.\n         *\n         * @param  {Object} xy The point\n         * @param  {Number} xy.x\n         * @param  {Number} xy.y\n         *\n         * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n         */\n        fromPoint: function(xy){\n            return new REGION({\n                        top    : xy.y,\n                        bottom : xy.y,\n                        left   : xy.x,\n                        right  : xy.x\n                    })\n        }\n    }\n\n    Object.keys(statics).forEach(function(key){\n        REGION[key] = statics[key]\n    })\n\n    REGION.init()\n}"]},"metadata":{},"sourceType":"script"}